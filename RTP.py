# Reliable transport protocol
# Sends messages that are checked for arrival
# Header:
# type | sequence number

import logging
import time

from general_utility import *

# Gets the window from the packet, used for peeking
def get_window(packet):

	# Get the readable form of the packet
	(dest_port, source_id, source_port, message) = packet

	# Separate the header from the body
	header = message[:gen_header_size()]
	body = message[gen_header_size():]

	return int(body)

# The size of the header generated by this layer
# Expected size
# type	| sequence number
# 4	| 4
# Total: 8
def gen_header_size():

	return (field_size * 2)

# The total size of the header including the lower layer header
# Expected size
# DNP layer	| RTP layer
# 48		| 8
def gen_header_total():

	return self.DNP.header_total() + self.header_size()

class RTP:

	# timeout determines how long to wait for AKs of any kind
	# Set target port if this is accepting a request
	def __init__(self, node_id, service_id, DNP, target_id, connected_to, target_port=None, listen_port=10, timeout=.5, window=5, default_max = 1000):

		self.node_id = node_id

		# The service id of this connection
		self.service_id = service_id

		# The id of the node being communicated to
		self.target_id = target_id

		# For tracking connected ports
		self.connected_to = connected_to

		# The port for requesting new connections
		self.listen_port = listen_port

		# This is used to send single packets
		self.DNP = DNP

		# This is the timeout for waiting on AKs
		self.timeout=.5

		# This is the timeout for closing the service
		self.close_timeout = 6 * self.timeout

		# This is the number of packets to allow in flight
		self.window = window

		# The is how big to make packets by default in bytes
		self.default_max = 1000

		# If the connection is active
		self.connected = False

		# Tracks the stage in the stream
		# 1 - request connection
		# 2 - accept a request
		# 3 - finalize handshake
		# 4 - active
		self.stage = 1

		# Counters for each handshake stage
		self.request_counter = 0
		self.accept_counter = 0
		self.finalize_counter = 0

		# Max values for each counter
		self.request_max = 6
		self.accept_max = 6
		self.finalize_max = 6

		# If target port is sent, advance stage and set port
		if target_port:

			self.stage = 2

			self.target_port = target_port

			# Send the accept message
			self.accept()

		# Otherwise, initiate the connection
		else:

			self.request()

	# Opens new packets
	def serve(self, packet):

		# Get the readable form of the packet
		(dest_port, source_id, source_port, message) = packet

		# Separate the header from the body
		header = message[:self.header_size()]
		body = message[self.header_size():]

		# Get the header info
		(pkt_type, sequence_num) = unpack_string(header)
		pkt_type = int(pkt_type)

		# Execution depends on connection state and packet type

		# Request
		# Not needed here?
		if pkt_type == 1:

			# Window size
			self.window = int(message)

			# Set the target based on the sender service id
			self.target_port = source_port

			self.accept()

			if self.stage < 2:
				self.stage = 2

		# Accept
		elif pkt_type == 2:

			# Set the target based on the sender service id
			self.target_port = source_port

			# Time since last finalize
			self.last_finalize = time.time()

			self.finalize()

			if self.stage < 3:
				self.stage = 3

		# Finalize
		elif pkt_type == 3:

			if self.stage < 4:
				self.stage = 4

				logging.warning("Established connection to: " + str(self.target_id))

				# Add to the connected list
				self.connected_to.append((self.service_id, self.target_id, self.target_port))

		# Not known type
		else:

			logging.error("Packet type not known: " + str(pkt_type))

	# Sends a message reliably
	def send(self):

		pass

	# Does maintainence on the connection
	def cleanup(self):

		# Based on stage, do cleanup

		# Requesting
		if self.stage == 1:

			# Resend request
			self.request()

		# Accepting
		elif self.stage == 2:

			# Resend accept
			self.accept()

		# Finalizing
		elif self.stage == 3:

			# If no accepts have been recieved in a while, connection is active
			if(self.last_finalize_time and self.last_finalize_time > self.timeout*self.accept_max):

				self.stage = 4

				logging.warning("Finalized connection to: " + str(self.target_id))

				# Add to the connected list
				self.connected_to.append((self.service_id, self.target_id, self.target_port))

			else:

				# Resend finalize
				self.finalize()

		# Active
		else:

			pass

	# Sends a request, step 1 in handshake
	def request(self):

		logging.info("Requesting connection with: " + str(self.target_id))

		# Increment counter
		self.request_counter += 1

		# If this has reached max, throw an error
		if self.request_counter > self.request_max:

			raise RuntimeError("Request limit reached")

		# Get the header for the packet
		# This is also the only content
		message = pack_string([1,0]) + str(self.window)

		# Send this message
		self.DNP.send(message, self.target_id, self.listen_port, self.service_id)

	# Accepts the request and replies with the AK, step 2 in handshake
	def accept(self):

		logging.info("Accepting connection from: " + str(self.target_id) + " connecting to port: " + str(self.target_port))

		# Increment counter
		self.accept_counter += 1

		# If this has reached max, throw an error
		if self.accept_counter > self.accept_max:

			raise RuntimeError("Accept limit reached")

		# Get the header for the packet
		# This is also the only content
		message = pack_string([2,0])

		# Send this message
		self.DNP.send(message, self.target_id, self.target_port, self.service_id)

		# Add to the connected list
		#self.connected_to.append((self.target_id, self.target_port))

	# Finalizes handshake, step 3 in handshake
	def finalize(self):

		try:
			self.last_finalize_time

		except AttributeError:
			self.last_finalize_time = time.time()

		logging.info("Finalizing connection with: " + str(self.target_id))

		# Increment counter
		self.finalize_counter += 1

		#self.last

		# If this has reached max, throw an error
		if self.finalize_counter > self.finalize_max:

			raise RuntimeError("Finalize limit reached")

		# Get the header for the packet
		# This is also the only content
		message = pack_string([3,0])

		# Send this message
		self.DNP.send(message, self.target_id, self.target_port, self.service_id)

		# Add to the connected list
		#self.connected_to.append((self.target_id, self.target_port))

	# The size of the header generated by this layer
	# Expected size
	# type	| sequence number
	# 4	| 4
	# Total: 8
	def header_size(self):

		return (field_size * 2)

	# The total size of the header including the lower layer header
	# Expected size
	# DNP layer	| RTP layer
	# 48		| 8
	def header_total(self):

		return self.DNP.header_total() + self.header_size()
